name: Multi-Stage Deployment

on:
  push:
    branches: [ main ]
    paths:
      # Only trigger on changes to the web app or this workflow file
      - '03-infrastructure-as-code/code-labs/ci-cd-labs/**'
      - '.github/workflows/advanced-cicd.yml'
  pull_request:
     paths:
      - '03-infrastructure-as-code/code-labs/ci-cd-labs/**'
  

  # This allows you to run it manually from the "Actions" tab for testing
  workflow_dispatch:

jobs:
  #Security Scan (Runs in parallel with Build)
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs' # Scan the filesystem
          scan-ref: './03-infrastructure-as-code/code-labs/ci-cd-labs/web-app-project'
          scanners: 'vuln,config,secret' # Adds secret and config scanning
          exit-code: '1' # This forces the job to FAIL if it finds anything
          ignore-unfixed: true
          format: 'table'
          severity: 'CRITICAL,HIGH'

  # STAGE 1: BUILD
  build-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Simulate Build
        run: |
          mkdir build-assets
          echo "Build Version 1.0.23" > build-assets/version.txt
          # Copy your existing index.html instead of overwriting it
          cp 03-infrastructure-as-code/code-labs/ci-cd-labs/web-app-project/index.html build-assets/

      - name: Save Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-artifact
          path: build-assets/

  # STAGE 2: STAGING (Depends on Build)
  deploy-staging:
    needs: [build-job, security-scan]
    runs-on: ubuntu-latest
    environment: 
      name: staging
      url: ${{ steps.deployment.outputs.page_url }} # This creates a clickable link in GitHub!
    permissions:
      pages: write      # Required for deploying to Pages
      id-token: write   # Required for security OIDC
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-artifact
      - name: Customize for Staging
        run: |
          # Inject the Environment Name
          sed -i 's/__ENVIRONMENT__/STAGING_SERVER/g' index.html
          # Inject the Short Commit SHA (First 7 characters)
          sed -i "s/__COMMIT_ID__/${GITHUB_SHA::7}/g" index.html
      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: '.' # Deploys the current folder containing index.html

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # # STAGE 3: PRODUCTION (Depends on Staging)
  # deploy-production:
  #   needs: deploy-staging
  #   runs-on: ubuntu-latest
  #   environment: production
  #   steps:
  #     - name: Download Artifact
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: app-artifact

  #     # 1. VERIFY FIRST: Make sure we have the right file before touching production
  #     - name: Verify Version
  #       run: |
  #         VERSION=$(cat version.txt)
  #         if [ "$VERSION" == "Build Version 1.0.23" ]; then
  #           echo "SUCCESS: Version matches. Proceeding..."
  #         else
  #           echo "ERROR: Version mismatch!"
  #           exit 1
  #         fi
  #     - name: Customize for Production
  #       run: |
  #         # Inject the Environment Name
  #         sed -i 's/__ENVIRONMENT__/PRODUCTION_RELEASE/g' index.html
  #         # Inject the Short Commit SHA
  #         sed -i "s/__COMMIT_ID__/${GITHUB_SHA::7}/g" index.html
          
  #     # 2. ATTEMPT DEPLOY
  #     - name: Deploy to Production
  #       id: deploy_step
  #       run: |
  #         echo "Attempting to deploy Build Version 1.0.23..."
  #         # Simulate a deployment failure for demonstration
  #         echo "ERROR: Deployment failed due to network issue."
  #         # Change 1 to 0 to simulate success
  #         exit 0 

  #     # 3. ROLLBACK IF DEPLOY FAILED
  #     - name: Rollback to Last Stable Version
  #       if: failure() && steps.deploy_step.outcome == 'failure'
  #       run: |
  #         echo "CRITICAL: Production deployment failed!"
  #         echo "Action: Reverting to previous stable build..."
  
# STAGE 3: PRODUCTION (AWS S3 + CloudFront)
  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write # Required for OIDC
      contents: read
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-artifact

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      # - name: Force Failure for Notification Test
      #   run: |
      #     echo "Testing DevOps Alerting System..."
      #     exit 1 # This forces the job to fail with a non-zero exit code

      - name: Debug and Customize
        run: |
          echo "--- LISTING ALL FILES (Recursive) ---"
          ls -R
          
          echo "--- STARTING REPLACEMENT ---"
          # This finds any index.html in any folder and runs sed on it
          find . -name "index.html" -type f -exec sed -i 's/__ENVIRONMENT__/PRODUCTION_RELEASE/g' {} +
          find . -name "index.html" -type f -exec sed -i "s/__COMMIT_ID__/${GITHUB_SHA::7}/g" {} +
          
          echo "--- VERIFYING CHANGE ---"
          # This helps us see if the replacement actually happened in the logs
          find . -name "index.html" -type f -exec grep -H "PRODUCTION_RELEASE" {} +

      # 1. Sync files to S3 (This is the actual deployment)
      - name: Deploy to S3
        run: |
          aws s3 sync . s3://${{ secrets.AWS_S3_BUCKET }} --delete --exclude ".git/*"

      # 2. Clear the CloudFront Cache (So changes show up immediately)
      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
  notifications:
    needs: [security-scan, build-job, deploy-staging, deploy-production]
    if: always() # This ensures the job RUNS even if others fail
    runs-on: ubuntu-latest
    steps:
      - name: Discord Notification
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK }}
          # Logic: If 'failure' is found anywhere in the results, send 'failure' status
          status: ${{ (contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')) && 'failure' || 'success' }}
          title: "Pipeline Status"
          description: |
            **Current Results:**
            • Security: ${{ needs.security-scan.result }}
            • Build: ${{ needs.build-job.result }}
            • Staging: ${{ needs.deploy-staging.result }}
            • Production: ${{ needs.deploy-production.result }}